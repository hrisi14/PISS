#############################################################################
### Търсене и извличане на информация. Приложение на дълбоко машинно обучение
### Стоян Михов
### Зимен семестър 2025/2026
#############################################################################
###
### Домашно задание 2 -- функции за семплиране на думи
###
#############################################################################

# %%
import random
import numpy as np

#############################################################
###  Случайна извадка от негативни примери --
###  избира от зададена последователност за семплиране seq
###  negativesCount на брой негативни примери различни от c.
###  Връща списък, който съдържа на първа позиция c, а на следващите
###  negativesCount позиции -- негативни примери различни от c
#############################################################
# %%
def sampleContext(c,seq,negativesCount):
    context = [c]
    while len(context) <= negativesCount:
        cn = random.choice(seq)
        if cn != c:
            context.append(cn)
    return context

# %%
#############################################################
###  Създаване на последователност за семплиране
#############################################################
def createSamplingSequence(freqs):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща списък seq, в който броят на срещанията на даден индекс на терм
    ###  е пропорционален на желаната вероятност (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда
    seq = []
    freqs_arr = np.array(freqs, dtype=float)
    weights = np.round(freqs_arr ** 0.75).astype(int)
    for i, w in enumerate(weights):
        if w > 0:
            seq.extend([i] * w)
    return seq

    #### Край на Вашия код
    #############################################################################
    return seq

# %%
#############################################################
###  Създаване на последователност за семплиране
#############################################################
def noiseDistribution(freqs,negativesCount):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща вектор q_noise, с дължина броя на думите в речника, в който 
    ###  на позиция  i стойността следва да е логаритъм от negativesCount по вероятността 
    ###  на терма с индекс i (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда
    probs = []
    freqs_arr = np.array(freqs, dtype=float)
    total_sum = np.sum(np.round(freqs_arr ** 0.75))
    len_freqs = len(freqs)
    for i in range(len_freqs):        
        p = round(freqs_arr[i] ** 0.75)/ total_sum
        probs.append(p)

    
    q_noise = np.zeros(len_freqs)
    for i in range(len_freqs):
        q_noise[i] = np.log(negativesCount * probs[i])        

    #### Край на Вашия код
    #############################################################################
    return q_noise



# %%
